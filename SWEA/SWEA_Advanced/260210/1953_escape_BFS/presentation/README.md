## 🎙️ [강의] 탈주범 검거: BFS와 Queue의 메커니즘

### 1. BFS를 왜 쓸까? (핵심 로직)

DFS가 한 놈만 패면서 끝까지 가보는 거라면, BFS는 **내 주변부터 공평하게 한 칸씩** 넓혀가는 거야. 탈주범이 1시간에 1칸씩 가니까, "L시간 동안 퍼져나갈 수 있는 모든 구역"을 찾기에 딱이지. 여기서 **Queue(큐)**는 **"다음에 가볼 곳들을 순서대로 적어둔 대기표"**라고 생각하면 돼.

### 2. Queue의 동작과 변수 변화 (상세 분석)

네 코드의 `queue = deque([(i, j, 1)])` 부분을 집중적으로 보자.

#### ① 큐에 데이터 넣기 (Push/Append)

* **상황:** 현재 위치 `(i, j)`에서 연결된 다음 칸 `(ni, nj)`를 발견했어!
* **동작:** "야, 너도 나중에 가봐야 하니까 줄 서!" 하고 큐 뒤에 붙여.
* **데이터:** `(ni, nj, curr_time + 1)`. 여기서 `time`을 1 늘려서 저장하는 게 핵심이야. 그래야 내가 몇 시간째에 거기 도착했는지 알 수 있거든.

#### ② 큐에서 데이터 빼기 (Popleft)

* **상황:** 현재 칸에서 할 일을 다 했어. 이제 다음 대기자를 불러야지?
* **동작:** `queue.popleft()`. 줄 맨 앞에 서 있던 놈을 꺼내서 **현재 조사 대상**으로 삼아.

---

## 📊 변수 추적 시뮬레이션 (Trace Table)

`L = 3` (3시간)이고 시작점이 `(0,0)`이라 가정해보자.

| 스텝 | Queue 상태 (맨 앞이 다음 대상) | 현재 조사 중 (`popleft`) | `count` | 비고 |
| --- | --- | --- | --- | --- |
| **1** | `[(0,0,1)]` | - | 1 | 시작점 큐에 넣고 count 시작 |
| **2** | `[]` | `(0,0,1)` | 1 | `(0,0)` 주변 조사 시작. 상하좌우 체크! |
| **3** | `[(0,1,2), (1,0,2)]` | - | 3 | 연결된 두 곳을 큐에 추가. `time`은 2가 됨. |
| **4** | `[(1,0,2)]` | `(0,1,2)` | 3 | `(0,1)` 주변 조사. 새로 갈 곳 없으면 끝. |
| **5** | `[(1,1,3)]` | `(1,0,2)` | 4 | `(1,0)` 주변 조사 중 `(1,1)` 발견! 큐에 추가. |

> **중요!** 만약 `popleft` 했을 때 `curr_time >= L`이면, 그 놈은 큐에서 빠지기만 하고 주변 조사를 안 해. 시간이 다 됐으니까! 이게 네 코드의 `if curr_time >= L: continue` 로직이야.

---

## 🎙️ 발표용 대본 (상세 버전)

### 1. 도입부

"이 문제는 탈주범이 이동한 시간 내에 존재할 수 있는 모든 위치를 찾는 문제입니다. **'동일한 시간대에 퍼져나가는'** 특성을 고려하여 BFS 알고리즘을 선택했습니다."

### 2. 자료구조 설정 (Pipe & Oppo)

"먼저 `pipe` 딕셔너리로 7가지 파이프의 연결 방향을 정의했고, `oppo` 딕셔너리를 통해 상하좌우의 반대 방향을 매핑했습니다. **내가 위(0)로 가려면, 다음 칸 파이프는 아래(1)가 뚫려 있어야 한다**는 로직을 `is_connected` 함수로 깔끔하게 처리했습니다."

### 3. BFS와 큐 작동 원리 (핵심)

"가장 중요한 BFS 부분입니다. `deque`를 이용해 방문할 지점과 현재 시간을 함께 큐에 넣습니다.

1. 큐에서 하나를 꺼내(`popleft`) 현재 위치로 잡습니다.
2. 현재 파이프에서 갈 수 있는 방향을 `for`문으로 돌립니다.
3. 다음 칸이 **격자 내에 있고, 방문한 적 없으며, 현재 파이프와 연결**되어 있다면 방문 표시를 하고 큐에 넣습니다.
이때 `curr_time + 1`을 함께 저장하여 시간 흐름을 관리하고, 설정된 시간 `L`에 도달하면 더 이상 확산하지 않도록 `continue`로 제어했습니다."

---

## 🧐 기술적 분석 (Best Practice)

| 특징 | 장점 | 단점 |
| --- | --- | --- |
| **`deque` 사용** | 일반 `list.pop(0)`은 $O(N)$이지만, `deque.popleft()`는 $O(1)$이라 성능이 압도적임. | `collections` 모듈을 임포트해야 함. |
| **방향 역전 (`oppo`)** | `if`문을 도배하는 대신 딕셔너리로 간단히 해결. (매우 전문적임) | 딕셔너리 정의할 때 오타 나면 찾기 힘듦. |

---
